<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="vector容器与数组类似，也称为单端数组，vector可以动态扩展，空间满后，寻找更大的新空间，将原有数组拷贝到新空间 vector迭代器支持随机访问 vector构造函数无参构造 通过输入迭代器的区间进行构造 通过n个elm进行构造 拷贝构造 vector赋值操作12345vector&amp; operator&#x3D;(const vector &amp;vec);  &#x2F;&#x2F;重载等号assign(b">
<meta property="og:type" content="article">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/2021/09/25/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%92%8C%E7%AE%97%E6%B3%95/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="vector容器与数组类似，也称为单端数组，vector可以动态扩展，空间满后，寻找更大的新空间，将原有数组拷贝到新空间 vector迭代器支持随机访问 vector构造函数无参构造 通过输入迭代器的区间进行构造 通过n个elm进行构造 拷贝构造 vector赋值操作12345vector&amp; operator&#x3D;(const vector &amp;vec);  &#x2F;&#x2F;重载等号assign(b">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-09-25T15:32:52.504Z">
<meta property="article:modified_time" content="2021-09-25T15:32:52.505Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-STL常用容器和算法" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/25/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%92%8C%E7%AE%97%E6%B3%95/" class="article-date">
  <time class="dt-published" datetime="2021-09-25T15:32:52.504Z" itemprop="datePublished">2021-09-25</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="vector容器"><a href="#vector容器" class="headerlink" title="vector容器"></a>vector容器</h1><p>与数组类似，也称为单端数组，vector可以动态扩展，空间满后，寻找更大的新空间，将原有数组拷贝到新空间</p>
<p>vector迭代器支持随机访问</p>
<h4 id="vector构造函数"><a href="#vector构造函数" class="headerlink" title="vector构造函数"></a>vector构造函数</h4><p>无参构造</p>
<p>通过输入迭代器的区间进行构造</p>
<p>通过n个elm进行构造</p>
<p>拷贝构造</p>
<h4 id="vector赋值操作"><a href="#vector赋值操作" class="headerlink" title="vector赋值操作"></a>vector赋值操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vector&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> vector &amp;vec);  <span class="comment">//重载等号</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assign</span>(beg,end);	<span class="comment">//将[beg,end）的数据（此处还是指迭代器范围）拷贝赋值给本身</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">assign</span>(n,elem);     <span class="comment">//将n个elem赋值给自身</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>assign()</code>理解为会把之前所有的值删除，然后赋参数列表里的值,与等号的作用等价</p>
</blockquote>
<h4 id="vector容量和大小"><a href="#vector容量和大小" class="headerlink" title="vector容量和大小"></a>vector容量和大小</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">empty</span>(); <span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="built_in">capacity</span>(); <span class="comment">//容器的容量</span></span><br><span class="line"><span class="built_in">size</span>();	<span class="comment">//容器的大小</span></span><br><span class="line"><span class="built_in">resize</span>();	<span class="comment">//重新指定大小，如果重新指定的大小比原来长，默认用0填充</span></span><br><span class="line">			<span class="comment">//如果重新指定的大小比原来小，会删除超出部分元素</span></span><br></pre></td></tr></table></figure>

<h4 id="vector插入和删除"><a href="#vector插入和删除" class="headerlink" title="vector插入和删除"></a>vector插入和删除</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">push_back</span>(ele);</span><br><span class="line"><span class="built_in">pop_back</span>();</span><br><span class="line"><span class="built_in">insert</span>(const_iterator pos,ele); <span class="comment">//在迭代器位置插入元素</span></span><br><span class="line"><span class="built_in">insert</span>(const_iterator pos,count,ele);<span class="comment">//在迭代器位置插入n个元素</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator pos);<span class="comment">//删除指定位置</span></span><br><span class="line"><span class="built_in">erase</span>(const_iterator beg,const_iterator end);<span class="comment">//删除指定范围，若范围为begin()和end()，等价于清空											</span></span><br><span class="line"><span class="built_in">clear</span>();<span class="comment">//清空容器内容</span></span><br></pre></td></tr></table></figure>

<h4 id="vector数据存取"><a href="#vector数据存取" class="headerlink" title="vector数据存取"></a>vector数据存取</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">at</span>(<span class="keyword">int</span> idx);	<span class="comment">//返回索引idx所指的数据</span></span><br><span class="line"><span class="keyword">operator</span>[];		<span class="comment">//返回索引idx所指的数据</span></span><br><span class="line"><span class="built_in">front</span>();		<span class="comment">//返回容器中第一个数据元素</span></span><br><span class="line"><span class="built_in">back</span>();			<span class="comment">//返回最后一个元素</span></span><br></pre></td></tr></table></figure>

<p>除了迭代器，也可以用  <code>[]</code> 和 <code>at()</code> 等进行访问vector中的元素</p>
<h4 id="vector互换容器"><a href="#vector互换容器" class="headerlink" title="vector互换容器"></a>vector互换容器</h4><p>实现两个容器内元素进行互换</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>();</span><br></pre></td></tr></table></figure>

<p>巧用swap()可以收缩内存：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt;(v).<span class="built_in">swap</span>(v);</span><br><span class="line"><span class="comment">//vector&lt;int&gt;(v)   申请了一个匿名对象，内容用v拷贝</span></span><br><span class="line"><span class="comment">//匿名对象会在执行完语句后释放</span></span><br></pre></td></tr></table></figure>

<h4 id="vector预留空间"><a href="#vector预留空间" class="headerlink" title="vector预留空间"></a>vector预留空间</h4><p>减少vector在动态扩展容量时的扩展次数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">reserve</span>(<span class="keyword">int</span> space);     <span class="comment">//若数据量较大，预留空间可以减少动态扩展的次数</span></span><br></pre></td></tr></table></figure>



<h1 id="deque容器"><a href="#deque容器" class="headerlink" title="deque容器"></a>deque容器</h1><h4 id="deque容器的基本概念"><a href="#deque容器的基本概念" class="headerlink" title="deque容器的基本概念"></a>deque容器的基本概念</h4><ul>
<li>双端数组，也可以对头端进行插入删除操作</li>
</ul>
<p>vector对于头部的数据插入删除效率低，需要移动大量元素</p>
<ul>
<li><p>工作原理：</p>
<p>deque容器内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p>
<p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p>
</li>
</ul>
<h4 id="deque构造函数"><a href="#deque构造函数" class="headerlink" title="deque构造函数"></a>deque构造函数</h4><p><code>deque&lt;T&gt;deq;</code>        //默认构造</p>
<p><code>deque(beg,end);    </code>        //将迭代器[beg,end)区间中的元素拷贝给本身</p>
<p><code>deque(n,elem);</code>        //构造函数将n个elem传入本身</p>
<p><code>deque(const deque &amp;deq);</code>         //拷贝构造函数</p>
<blockquote>
<p>补充一点：函数参数是容器，且要加<code>const</code>修饰时，迭代器也要改为<code>const_iterator</code></p>
</blockquote>
<h4 id="deque容器赋值操作"><a href="#deque容器赋值操作" class="headerlink" title="deque容器赋值操作"></a>deque容器赋值操作</h4><p><code>deque&amp; operator=(const deque &amp;deq);</code>          //重载等号</p>
<p><code>assign(beg,end);</code>        //通过另一个容器范围内的值进行赋值</p>
<p><code>assign(n,ele);</code>        //n个ele元素进行赋值</p>
<blockquote>
<p> <code>assign()</code>理解为会把之前所有的值删除，然后赋参数列表里的值,与等号的作用等价</p>
</blockquote>
<h4 id="deque容器大小操作"><a href="#deque容器大小操作" class="headerlink" title="deque容器大小操作"></a>deque容器大小操作</h4><p><code>deque.empty()</code>         //判断容器是否为空</p>
<p><code>deque.size()</code>         //返回容器的大小</p>
<p><code>deque.resize(n)</code>     //重新指定大小,若比原来长，默认0填充</p>
<p>​                                     //若比原来短，相当于删除末尾元素</p>
<h4 id="deque容器插入和删除"><a href="#deque容器插入和删除" class="headerlink" title="deque容器插入和删除"></a>deque容器插入和删除</h4><ul>
<li><p>两端插入和删除</p>
<p><code>push_back(elem);</code>        //尾插</p>
<p><code>push_front(elem);</code>        //头插</p>
<p><code>pop_back()</code>         //尾删</p>
<p><code>pop_front()</code>         //头删</p>
</li>
</ul>
<ul>
<li><p>指定位置操作</p>
<p><code>insert(const_iterator pos,elem);</code>     //pos位置插入一个elem元素的拷贝，返回新元素的位置（数据类型为迭代器类型）</p>
<p><code>insert(const_iterator pos,n,elem);</code>     //pos位置插入n个elem元素的拷贝，无返回值</p>
<p><code>insert(pos,beg,end);</code>     //pos位置插入[beg,end)区间的值，无返回值，相比vector多了此重载版本</p>
<p><code>clear();</code>     //清空deque</p>
<p><code>erase(beg,end);</code>     //删除[beg,end)区间内的值，返回下一个数据值位置</p>
<p><code>erase(pos);</code>     //删除pos位置的值，返回下一个数据的位置</p>
</li>
</ul>
<h4 id="deque容器数据存取"><a href="#deque容器数据存取" class="headerlink" title="deque容器数据存取"></a>deque容器数据存取</h4><p><code>at(int idx);</code>     //返回索引idx所指的数据</p>
<p><code>operator[];</code>     //重载[]，返回索引idx所指的元素</p>
<p><code>front();</code>     //返回容器中第一个数据元素</p>
<p><code>back();</code>      //返回容器中最后一个数据元素</p>
<p>除了迭代器，也可以用  <code>[]</code> 和 <code>at()</code> 等进行访问deque中的元素</p>
<h4 id="deque容器排序操作"><a href="#deque容器排序操作" class="headerlink" title="deque容器排序操作"></a>deque容器排序操作</h4><p><code>sort(iterator beg,iterator end);</code>     //对区间内的元素进行排序</p>
<h1 id="stack容器"><a href="#stack容器" class="headerlink" title="stack容器"></a>stack容器</h1><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><p>先进后出，只有一个出口</p>
</li>
<li><p>栈不允许有遍历行为，只能访问栈顶元素</p>
</li>
</ul>
<h4 id="stack常用接口"><a href="#stack常用接口" class="headerlink" title="stack常用接口"></a>stack常用接口</h4><p>构造函数</p>
<p><code>stack&lt;T&gt; stk;</code>     //默认构造</p>
<p><code>stack(const stack &amp;stk);</code>     //拷贝构造函数</p>
<p>赋值操作</p>
<p><code>stack&amp; operator=(const stack &amp;stk);</code>     //重载等号操作符</p>
<p>数据存取</p>
<p><code>push(elm);</code>     //向栈顶添加元素</p>
<p><code>pop();</code>     //移除栈顶元素</p>
<p><code>top();</code>     //返回栈顶元素</p>
<p>大小操作：</p>
<p><code>empty();</code>     //判断栈是否为空</p>
<p><code>size();</code>     //返回栈的大小</p>
<h1 id="queue容器"><a href="#queue容器" class="headerlink" title="queue容器"></a>queue容器</h1><p>队列(queue)是一种先进先出的数据结构，一端只能出队，一端只能入队，只能访问队头和队尾元素，不允许遍历行为</p>
<h4 id="queue容器常用接口"><a href="#queue容器常用接口" class="headerlink" title="queue容器常用接口"></a>queue容器常用接口</h4><p>构造函数</p>
<p><code>queue&lt;T&gt; que;</code>   //模板类实现，默认构造</p>
<p><code>queue(const queue &amp;que);</code>     //拷贝构造函数</p>
<p>赋值操作</p>
<p><code>queue&amp; operator=(const queue &amp;que);</code>     //重载等号运算符</p>
<p>数据存取</p>
<p><code>push(elem);</code>     //队尾添加元素</p>
<p><code>pop();</code>     //移除队头元素</p>
<p><code>back();</code>     //返回最后一个元素</p>
<p><code>front();</code>     //返回第一个元素</p>
<p>大小操作</p>
<p><code>empty();</code>     //判断是否为空</p>
<p><code>size()；</code>     //返回队列大小</p>
<h1 id="List容器"><a href="#List容器" class="headerlink" title="List容器"></a>List容器</h1><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>链表，使用非连续的内存地址，将数据进行链式存储，由一系列结点构成</p>
<p>STL中的List链表是双向循环链表，链表的存储方式并不是连续的内存空间，其迭代器只支持前移和后移，属于双向迭代器</p>
<p>插入和删除不会造成list 迭代器的失效，这在vector中不成立</p>
<h4 id="list构造函数"><a href="#list构造函数" class="headerlink" title="list构造函数"></a>list构造函数</h4><p><code>list&lt;T&gt; lst;</code>     //模板类实现，默认构造</p>
<p><code>list(beg,end);</code>     //将迭代器[beg,end)区间 元素拷贝给自身</p>
<p><code>list(n,elem);</code>     //将n个elem 拷贝给自身</p>
<p><code>list(const list &amp;lst);</code>      //拷贝构造函数</p>
<h4 id="list赋值和交换"><a href="#list赋值和交换" class="headerlink" title="list赋值和交换"></a>list赋值和交换</h4><p><code>assign(beg,end);</code>     //将迭代器[beg,end)范围内的数拷贝赋值给本身</p>
<p><code>assign(n,elem);</code>     //赋值n个elem</p>
<p><code>list&amp; operator=(const list &amp;lst);</code>     //重载等号</p>
<p><code>swap(lst);</code>     //将lst与本身的元素互换，即使长度不同也可以互换</p>
<h4 id="list大小操作"><a href="#list大小操作" class="headerlink" title="list大小操作"></a>list大小操作</h4><p><code>empty();</code>     </p>
<p><code>size();</code></p>
<p><code>resize(num);</code>     //重新指定list的长度为num，若容器边长，则以默认值填充新位置</p>
<p>​                                       //若变短，则删除超出长度的元素</p>
<p><code>resize(num,elem);</code></p>
<h4 id="list插入和删除"><a href="#list插入和删除" class="headerlink" title="list插入和删除"></a>list插入和删除</h4><p><code>push_back(elem);</code>        //尾插</p>
<p><code>push_front(elem);</code>        //头插</p>
<p><code>pop_back()</code>         //尾删</p>
<p><code>pop_front()</code>         //头删</p>
<p><code>insert(const_iterator pos,elem);</code>     //pos位置插入一个elem元素的拷贝，返回新元素的位置（数据类型为迭代器类型）</p>
<p><code>insert(const_iterator pos,n,elem);</code>     //pos位置插入n个elem元素的拷贝，无返回值</p>
<p><code>insert(pos,beg,end);</code>     //pos位置插入[beg,end)区间的值，无返回值，相比vector多了此重载版本</p>
<p><code>clear();</code>     //清空</p>
<p><code>erase(beg,end);</code>     //删除[beg,end)区间内的值，返回下一个数据值位置</p>
<p><code>erase(pos);</code>     //删除pos位置的值，返回下一个数据的位置</p>
<p><code>remove(elem);</code>     //删除容器中所有与elem值匹配的元素</p>
<blockquote>
<p> list的迭代器不支持随机访问，只能++或–，因为双向链表只知道当前结点的前驱和后继，再往后的结点就得访问其他结点才知道</p>
</blockquote>
<h4 id="list数据存取"><a href="#list数据存取" class="headerlink" title="list数据存取"></a>list数据存取</h4><p><code>front();</code>     //返回第一个元素</p>
<p><code>back();</code>     //返回最后一个元素</p>
<p>无法重载<code>[]</code>，也无法使用<code>at()</code>,因为list不是连续的内存空间</p>
<h4 id="list反转和排序"><a href="#list反转和排序" class="headerlink" title="list反转和排序"></a>list反转和排序</h4><p><code>reverse();</code>     //实现链表的反转</p>
<blockquote>
<p>关于排序，list容器不能直接使用algorithm提供的<code>sort()</code>,所有不支持随机访问迭代器的容器，都不可以用标准算法</p>
</blockquote>
<p>list内部提供了<code>sort()</code>成员函数</p>
<p><code>sort()</code>默认为升序排序，若要为降序，需要提供比较器</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> v1 &gt; v2 ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例：自定义数据类型<code>Person</code>，按照年龄升序，身高降序排列，需要提供：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comparePerson</span><span class="params">(Person &amp;p1,Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(p1.m_Age==p2.m_Age)</span><br><span class="line">        <span class="keyword">return</span> p1.m_Height&gt;p2.m_Height;</span><br><span class="line">    <span class="keyword">return</span> p1.m_Age&lt;p2.m_Age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="set-multiset容器"><a href="#set-multiset容器" class="headerlink" title="set/multiset容器"></a>set/multiset容器</h1><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p>所有元素都会在插入时自动被排序，set/multiset 属于<strong>关联式容器</strong>，底层用二叉树实现</p>
<p>set/multiset区别：</p>
<p>set不允许容器中有重复元素，multiset允许容器中有重复的元素</p>
<h4 id="set构造和赋值"><a href="#set构造和赋值" class="headerlink" title="set构造和赋值"></a>set构造和赋值</h4><p><code>set&lt;T&gt; st;</code>     //默认构造</p>
<p><code>set(const set &amp;st);</code>     //拷贝构造</p>
<p><code>set&amp; operator=(const set &amp;st)</code>     //重载等号操作符</p>
<p>set插入数据只有<code>insert()</code>方式</p>
<h4 id="set大小和交换"><a href="#set大小和交换" class="headerlink" title="set大小和交换"></a>set大小和交换</h4><p><code>size();</code>     //返回容器中元素的数目</p>
<p><code>empty();</code>     //判断是否为空</p>
<p><code>swap();</code>     //交换两个集合容器</p>
<h4 id="set插入和删除"><a href="#set插入和删除" class="headerlink" title="set插入和删除"></a>set插入和删除</h4><p><code>insert();</code>     //插入元素</p>
<p><code>clear();</code>     //清空</p>
<p><code>erase(pos);</code>     //删除pos迭代器所指的元素，返回下一个元素的迭代器</p>
<p><code>erase(beg,end);</code>     //删除区间[beg,end)的所有元素，返回下一个元素的迭代器</p>
<p><code>erase(elem);</code>     //删除容器中值为elem的元素</p>
<h4 id="set查找和统计"><a href="#set查找和统计" class="headerlink" title="set查找和统计"></a>set查找和统计</h4><p><code>find(key);</code>      //查找key是否存在，若存在，返回该元素的迭代器，若不存在，返回<code>set.end() </code></p>
<p><code>count (key);</code>     //返回key的元素个数</p>
<h4 id="set和multiset区别"><a href="#set和multiset区别" class="headerlink" title="set和multiset区别"></a>set和multiset区别</h4><p>set插入数据的同时会返回插入结果，表示插入是否成功</p>
<p>multiset不会检测数据重复性，因此可以插入重复数据</p>
<h4 id="pair对组创建"><a href="#pair对组创建" class="headerlink" title="pair对组创建"></a>pair对组创建</h4><p>成对出现的数据，利用对组可以返回两个数据,使用对组不需要包含头文件</p>
<p><code>pair&lt;type,type&gt; p (value1,value2);</code></p>
<p><code>pair&lt;type,type&gt; p = make_pair(value1,value2); </code></p>
<h4 id="set容器排序"><a href="#set容器排序" class="headerlink" title="set容器排序"></a>set容器排序</h4><p>set默认排序规则为从小到大，利用仿函数可以改变排序规则</p>
<p>存放内置数据类型的情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//仿函数：</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myCompare</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1&gt;v2;</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建set容器</span></span><br><span class="line">set&lt;<span class="keyword">int</span>,myCompare&gt; st;</span><br></pre></td></tr></table></figure>

<p>存放自定义数据类型的情况：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Person</span>(string name,<span class="keyword">int</span> age)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Name=name;</span><br><span class="line">        <span class="keyword">this</span>-&gt;m_Age=age;</span><br><span class="line">    &#125;</span><br><span class="line">    string m_Name;</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//对于自定义数据类型，set容器需要通过仿函数指定排序规则</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComparePerson</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; p1,<span class="keyword">const</span> Person&amp; p2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;		<span class="comment">//降序排列</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">set&lt;Person,ComparePerson&gt; st;</span><br></pre></td></tr></table></figure>



<h1 id="map-multimap容器"><a href="#map-multimap容器" class="headerlink" title="map/multimap容器"></a>map/multimap容器</h1><h4 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h4><p>map中所有元素都是pair，pair中第一个元素为key值(键值)，起索引作用，第二个值为value(实值)</p>
<p>所有元素都会根据元素的键值自动排序</p>
<p>map/multimap是关联式容器，底层用二叉树实现，根据key可以快速找到value值</p>
<p>map不允许有重复的key值元素，multimap允许容器有重复key值元素</p>
<h4 id="map构造和赋值"><a href="#map构造和赋值" class="headerlink" title="map构造和赋值"></a>map构造和赋值</h4><p>构造</p>
<p><code>map(T1,T2)mp;</code>     //默认构造</p>
<p><code>map(const map &amp;mp);</code>     //拷贝构造</p>
<p>赋值</p>
<p><code>map&amp; operator=(const map &amp;mp);</code>     //重载等号</p>
<p>map中所有数据都是成对出现，插入数据时要用对组<code>pair</code></p>
<h4 id="map大小和交换"><a href="#map大小和交换" class="headerlink" title="map大小和交换"></a>map大小和交换</h4><p><code>size();</code>     //返回容器中元素的数目</p>
<p><code>empty();</code>     //判断容器是否为空</p>
<p><code>swap();</code>      //交换两个map容器</p>
<h4 id="map插入和删除"><a href="#map插入和删除" class="headerlink" title="map插入和删除"></a>map插入和删除</h4><p><code>insert(elem)</code>     //在容器中插入元素，此处元素是<code>pair</code></p>
<p><code>clear();</code>     //清空map</p>
<p><code>erase(pos);</code>     //删除迭代器所指的元素，返回下一个元素的迭代器</p>
<p><code>erase(beg,end);</code>     //删除区间[beg,end)的元素，返回下一个元素的迭代器</p>
<p><code>erase(key);</code>     //删除容器中值为key的元素</p>
<p>map内部重载了<code>[]</code>，可以用key通过中括号访问value</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;m;</span><br><span class="line">m.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">1</span>,<span class="number">10</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(<span class="number">2</span>,<span class="number">20</span>));</span><br><span class="line">m.<span class="built_in">insert</span>(map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;::<span class="built_in">value_type</span>(<span class="number">3</span>,<span class="number">30</span>));</span><br></pre></td></tr></table></figure>



<h4 id="map查找和统计"><a href="#map查找和统计" class="headerlink" title="map查找和统计"></a>map查找和统计</h4><p><code>find(key);</code>     //查找key是否存在，返回该键的元素的迭代器，弱不存在返回map.end()</p>
<p><code>count(key);</code>     //统计key的元素个数</p>
<h4 id="map排序"><a href="#map排序" class="headerlink" title="map排序"></a>map排序</h4><p>改变排序顺序，或者对自定义数据类型排序，需要提供仿函数</p>
<h1 id="STL-函数对象"><a href="#STL-函数对象" class="headerlink" title="STL-函数对象"></a>STL-函数对象</h1><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>重载函数调用操作符<code>()</code>的类，其对象称为函数对象</p>
<p>函数对象使用重载的<code>()</code>时，行为类似函数调用，也叫仿函数</p>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><ul>
<li>函数对象在使用时，可以像普通函数一样调用，可以有参数，可以有返回值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Myadd</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> v1+v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">Myadd add;</span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>



<ul>
<li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li>
</ul>
<p>例：可以在类内添加count属性，统计函数对象调用次数</p>
<ul>
<li>函数对象可以作为参数传递</li>
</ul>
<h4 id="谓词"><a href="#谓词" class="headerlink" title="谓词"></a>谓词</h4><ul>
<li><p>谓词概念</p>
<p>返回<code>bool</code>类型的仿函数称为谓词，如果operator()接收一个参数，称为一元谓词，如果接收两个参数，称为二元谓词</p>
</li>
</ul>
<h4 id="内建函数对象"><a href="#内建函数对象" class="headerlink" title="内建函数对象"></a>内建函数对象</h4><p>STL内建了一些函数对象，包括：</p>
<ul>
<li>算术仿函数</li>
<li>关系仿函数</li>
<li>逻辑仿函数</li>
</ul>
<p>需要包含头文件<code>#include&lt;functional&gt;</code></p>
<h4 id="算术仿函数"><a href="#算术仿函数" class="headerlink" title="算术仿函数"></a>算术仿函数</h4><p><code>negate</code>是一元运算，其他都是二元运算</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">negate&lt;<span class="keyword">int</span>&gt; neg;</span><br><span class="line"><span class="keyword">int</span> a=<span class="built_in">neg</span>(<span class="number">50</span>);  <span class="comment">//a的结果为-50</span></span><br><span class="line"></span><br><span class="line">plus&lt;<span class="keyword">int</span>&gt;p;</span><br><span class="line">a=<span class="built_in">p</span>(<span class="number">10</span>,<span class="number">20</span>);    <span class="comment">//a的结果为30</span></span><br><span class="line"></span><br><span class="line">minus&lt;<span class="keyword">int</span>&gt;m;</span><br><span class="line">a=<span class="built_in">m</span>(<span class="number">10</span>,<span class="number">20</span>);    <span class="comment">//a的结果为-10</span></span><br></pre></td></tr></table></figure>



<h4 id="关系仿函数"><a href="#关系仿函数" class="headerlink" title="关系仿函数"></a>关系仿函数</h4><p><code>equal_to</code>，<code>not_equal_to</code>，<code>greater</code>，<code>greater_equal</code>，<code>less</code>，<code>less_equal</code></p>
<h4 id="逻辑仿函数"><a href="#逻辑仿函数" class="headerlink" title="逻辑仿函数"></a>逻辑仿函数</h4><p><code>logical_and</code>，<code>logical_or</code>，<code>logical_not</code></p>
<h1 id="STL-常用算法"><a href="#STL-常用算法" class="headerlink" title="STL 常用算法"></a>STL 常用算法</h1><h4 id="常用遍历算法"><a href="#常用遍历算法" class="headerlink" title="常用遍历算法"></a>常用遍历算法</h4><p><code>for_each</code>      //遍历容器</p>
<p><code>for_each(iterator beg,iterator end,_func)</code>;</p>
<p>第三个参数可以是函数，也可以是函数对象</p>
<p><code>transform</code>     //搬运容器到另一个容器中</p>
<p><code>transform(iterator beg1,ierator end1,ierator beg2,_func);</code></p>
<p>//参数：原迭代器begin，原迭代器end，目标迭代器begin，函数或函数对象</p>
<blockquote>
<p>注意，目标容器需要提前开辟空间（使用<code>resize</code>）</p>
</blockquote>
<h4 id="常用查找算法"><a href="#常用查找算法" class="headerlink" title="常用查找算法"></a>常用查找算法</h4><ul>
<li><p><code>find</code>      //查找指定元素，返回指定元素的迭代器，未找到返回结束迭代器end()</p>
<p><code>find(iterator beg,iterator end,value);</code></p>
<p><code>find</code>查找自定义数据类型时，需要重载<code>==</code></p>
</li>
</ul>
<ul>
<li><p><code>find_if</code>     //按条件查找元素</p>
<p><code>find_if(iterator beg,iterator end,_Pred);</code></p>
<p>//参数：迭代器begin，迭代器end，谓词（bool类型仿函数）</p>
</li>
</ul>
<ul>
<li><p><code>adjacent_find</code>     //查找相邻重复元素</p>
<p><code>adjacent_find(iterator beg,iterator end);</code></p>
<p>//beg 开始迭代器，end 结束迭代器    查找相邻重复元素，返回相邻元素的第一个位置的迭代器</p>
</li>
</ul>
<ul>
<li><p><code>binary_search</code>      //查找指定元素是否存在</p>
<p><code>bool binary_search(iterator beg,iterator end,value);</code></p>
<p>//查找指定的元素，查到返回true，否则返回false</p>
</li>
</ul>
<blockquote>
<p>​    注意：<code>binary_search</code>只能用于有序序列</p>
</blockquote>
<ul>
<li><p><code>count</code>     //统计元素的个数</p>
<p><code>count(iterator beg,iterator end,value);</code></p>
<p>//对于自定义数据类型需要重载<code>==</code></p>
</li>
</ul>
<ul>
<li><p>count_if      //按条件统计元素个数</p>
<p><code>count_if(iterator beg,iterator end,_Pred)</code></p>
<p>//参数：迭代器begin，迭代器end，谓词（bool类型仿函数）</p>
</li>
</ul>
<p>总结：对于自定义数据类型，需要重载符号，或提供一个谓词</p>
<h4 id="常用排序算法"><a href="#常用排序算法" class="headerlink" title="常用排序算法"></a>常用排序算法</h4><ul>
<li><p><code>sort</code>       //对容器内元素进行排序         </p>
<p><code>sort(iterator beg,iterator end,_Pred);</code></p>
<p>//修改排序规则或对于自定义数据类型需要提供谓词</p>
</li>
</ul>
<ul>
<li><p><code>random_shuffle</code>         //随机打乱容器中元素的顺序</p>
<p> <code>random_shuffle(iterator beg,iterator end);</code></p>
<p>//如果要每次随机结果不同，需要加上随机数种子</p>
</li>
<li><p><code>merge</code>         //将两个容器元素合并，并存储到另一容器，但两个容器必须是有序的（等同于归并排序的merge过程）</p>
<p><code>merge(ierator beg1,iterator end1,iterator beg2,ierator end2,ierator dest);</code></p>
<p>//beg1,end1,容器1的开始/结束迭代器</p>
<p>//beg2,end2,容器2的开始/结束迭代器</p>
<p>//dest,目标容器的开始迭代器</p>
<p>//dest容器需要使用<code>resize()</code>预先分配内存</p>
</li>
<li><p><code>reverse</code>           //将容器内元素进行反转</p>
<p><code>reverse(iterator beg,iterator end);</code></p>
</li>
</ul>
<h4 id="常用拷贝和替换算法"><a href="#常用拷贝和替换算法" class="headerlink" title="常用拷贝和替换算法"></a>常用拷贝和替换算法</h4><ul>
<li><p><code>copy</code>        //容器内指定范围的元素拷贝到另一容器中</p>
<p><code>copy(iterator beg,iterator end,iterator dest);</code></p>
<p>//beg,end,容器的开始/结束迭代器</p>
<p>//dest,目标容器的开始迭代器</p>
<p>//dest容器需要使用<code>resize()</code>预先分配内存</p>
<p>//相比于<code>copy</code>，<code>transform</code>更灵活，可以自定义函数或者函数对象，在搬运时对数据进行操作</p>
</li>
</ul>
<ul>
<li><p><code>replace</code>        //将容器内指定范围的旧元素修改为新元素</p>
<p><code>replace(iterator beg,iterator end,old_value,new_value);</code></p>
<p>//beg,end,容器的开始/结束迭代器</p>
<p>//old_value,new_value,旧元素/新元素</p>
</li>
</ul>
<ul>
<li><p><code>replace_if</code>       //将区间内满足条件的元素，替换成指定元素</p>
<p><code>replace_if(iterator beg,iterator end,_Pred,newvalue)</code></p>
<p>//beg,end,容器的开始/结束迭代器</p>
<p>//_Pred  谓词</p>
<p>//newvalue 替换的新元素</p>
</li>
</ul>
<ul>
<li><code>swap</code>       //替换两个同类型容器的元素</li>
</ul>
<h4 id="常用算术生成算法"><a href="#常用算术生成算法" class="headerlink" title="常用算术生成算法"></a>常用算术生成算法</h4><p>算术生成算法属于小型算法，使用时包含的头文件为<code>&lt;numeric&gt;</code></p>
<ul>
<li><p><code>accumulate</code>      //计算容器元素累计总和</p>
<p><code>accumulate(iterator beg,iterator end,value);</code></p>
<p>//beg,end,容器的开始/结束迭代器</p>
<p>//value,累加起始值，不需要起始值写0就可以</p>
</li>
</ul>
<ul>
<li><p><code>fill</code>     //向容器内填充指定的元素</p>
<p><code>fill(iterator beg,iterator end,value);</code></p>
<p>//beg,end,容器的开始/结束迭代器</p>
<p>//value，填充的值</p>
<blockquote>
<p>若是新建的容器，需要用<code>resize</code>预先指定其大小</p>
</blockquote>
</li>
</ul>
<h4 id="常用集合算法"><a href="#常用集合算法" class="headerlink" title="常用集合算法"></a>常用集合算法</h4><ul>
<li><p><code>set_intersection</code>          //求两个集合的交集</p>
<p><code>iterator set_intersection(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);</code></p>
<p>//目标容器需要用<code>resize</code>提前开辟空间</p>
<p>//<code>set_intersection</code>会返回交集end位置的迭代器</p>
</li>
<li><p><code>set_union</code>               //求两个集合的并集</p>
<p><code>set_union(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);</code></p>
<p>//目标容器需要用<code>resize</code>提前开辟空间</p>
<p>//<code>set_union</code>会返回并集end位置的迭代器</p>
</li>
</ul>
<ul>
<li><p><code>set_difference</code>      //求两个容器的差集</p>
<p><code>set_difference(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);</code></p>
<p>//目标容器需要用<code>resize</code>提前开辟空间</p>
<p>//<code>set_diference</code>会返回并集end位置的迭代器</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/25/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%92%8C%E7%AE%97%E6%B3%95/" data-id="cktzyeqnh0000uotp4ijcbl6i" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/09/20/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">第一篇博客</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/09/25/STL%E5%B8%B8%E7%94%A8%E5%AE%B9%E5%99%A8%E5%92%8C%E7%AE%97%E6%B3%95/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/09/20/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">第一篇博客</a>
          </li>
        
          <li>
            <a href="/2021/09/20/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>